
[zopepy]
recipe = zc.recipe.egg
#recipe = z3c.recipe.scripts:interpreter
eggs = ${instance-settings:eggs}
extra-paths = ${instance-settings:extra-paths}
interpreter = zopepy

[zeoserver]
recipe = plone.recipe.zeoserver
zeo-address = ${hosts:zeoserver}:${ports:zeoserver}
zeo-var = ${buildout:directory}/var
file-storage = ${zeoserver:zeo-var}/filestorage/Data.fs
blob-storage = ${zeoserver:zeo-var}/blobstorage
effective-user = ${users:zope}

[instance-debug]
recipe = plone.recipe.zope2instance
<= instance-settings
http-address = ${hosts:instance-debug}:${ports:instance-debug}
webdav-address = ${hosts:instance-debug}:${ports:instance-debug-dav}
debug-mode = on
verbose-security = on

[instance1]
recipe = plone.recipe.zope2instance
<= instance-settings
http-address = ${hosts:instance1}:${ports:instance1}
webdav-address = ${hosts:instance1}:${ports:instance1-dav}

[instance2]
recipe = plone.recipe.zope2instance
<= instance-settings
http-address = ${hosts:instance2}:${ports:instance2}
webdav-address = ${hosts:instance2}:${ports:instance2-dav}

[instance3]
recipe = plone.recipe.zope2instance
<= instance-settings
http-address = ${hosts:instance3}:${ports:instance3}
webdav-address = ${hosts:instance3}:${ports:instance3-dav}

[instance4]
recipe = plone.recipe.zope2instance
<= instance-settings
http-address = ${hosts:instance4}:${ports:instance4}
webdav-address = ${hosts:instance4}:${ports:instance4-dav}

##############################################################################
# special handling for C-Extensions
##############################################################################
[lxml]
recipe = z3c.recipe.staticlxml
egg = lxml

##############################################################################
# Set up supervisor to run it all
##############################################################################

[supervisor]
recipe = collective.recipe.supervisor
port = 127.0.0.1:${ports:supervisor}
user = ${supervisor-settings:user}
password = ${supervisor-settings:password}
serverurl = http://${hosts:supervisor}:${ports:supervisor}
plugins =
    superlance
programs =
    10 zeo       ${buildout:bin-directory}/zeoserver [fg] true ${users:zope}
    20 instance1 ${buildout:bin-directory}/instance1 [console] true ${users:zope}
    20 instance2 ${buildout:bin-directory}/instance2 [console] true ${users:zope}
    20 instance3 ${buildout:bin-directory}/instance3 [console] true ${users:zope}
    20 instance4 ${buildout:bin-directory}/instance4 [console] true ${users:zope}
    20 instance-debug (autostart=false) ${buildout:bin-directory}/instance4 [console] true ${users:zope}
    30 balancer  ${buildout:bin-directory}/haproxy  [-f ${buildout:directory}/etc/haproxy.conf -db] true ${users:balancer}
    50 cache     (autorestart=unexpected startretries=50) ${buildout:bin-directory}/cache     true ${users:cache}
eventlisteners =
    crashmail PROCESS_STATE ${buildout:bin-directory}/crashmail [-p cache -m "${supervisor-settings:mail}"]

# optional stuff/examples
#    40 transform ${nginx-build:location}/sbin/nginx [-c ${buildout:directory}/production/transform.conf]    true ${users:transform}
#    60 main      ${nginx-build:location}/sbin/nginx [-c ${buildout:directory}/production/main.conf]         true

[supervisord-rc-redhat]
recipe = collective.recipe.template
name = supervisord-plone
input = ${buildout:directory}/buildout.d/supervisord-redhat.rc.template
output = ${buildout:bin-directory}/supervisord-redhat.rc
mode = 0755

##############################################################################
# Backups
##############################################################################

[backup]
recipe = collective.recipe.backup

##############################################################################
# Build and configure haproxy
##############################################################################

[haproxy-build]
recipe = plone.recipe.haproxy
url = ${downloads:haproxy}
#target = linux26

[balancer]
recipe = collective.recipe.template
input = ${buildout:directory}/buildout.d/haproxy.conf.in
output = ${buildout:directory}/etc/haproxy.conf
maxconn = 24000
ulimit-n = 65536
user = ${users:balancer}
group = ${groups:balancer}
bind = ${hosts:balancer}:${ports:balancer}


##############################################################################
# Build and configure varnish
##############################################################################

[libpcre]
recipe = zc.recipe.cmmi
url = ${downloads:libpcre}

[varnish-build]
recipe = zc.recipe.cmmi
url = ${downloads:varnish}
extra_options =
    --with-pcre-config=${libpcre:location}/bin/pcre-config
environment =
    PCRE_CFLAGS=-I${libpcre:location}/include
    PCRE_LIBS=-L${libpcre:location}/lib -lpcre

[varnish-config]
recipe = collective.recipe.template
input = ${buildout:directory}/buildout.d/varnish.vcl.in
output = ${buildout:directory}/etc/varnish.vcl
# misc template variables
backend-host = ${hosts:balancer}
backend-port = ${ports:balancer}

[cache]
recipe = collective.recipe.template
input = ${buildout:directory}/buildout.d/varnishd.in
output = ${buildout:directory}/bin/cache
# misc template variables
daemon = ${varnish-build:location}/sbin/varnishd
config = ${varnish-config:output}
pid = ${buildout:directory}/var/cache.pid
bind = ${hosts:cache}:${ports:cache}
storage = ${buildout:directory}/var/storage
cache-size = 1G
mode = 0755

##############################################################################
# Apache configuration
##############################################################################

[apache-conf]
recipe = collective.recipe.template
input = ${buildout:directory}/buildout.d/apache.conf.in
output = ${buildout:directory}/etc/apache.conf

##############################################################################
# Solr configuration
##############################################################################
[solr-download]
recipe = hexagonit.recipe.download
strip-top-level-dir = true
url = http://apache.mirror.aussiehq.net.au/lucene/solr/3.4.0/apache-solr-3.4.0.tgz

[solr-conf]
recipe = collective.recipe.solrinstance
solr-location = ${solr-download:location}
host = localhost
port = 8983
basepath = /solr
#section-name = SOLR
# field name in index to take catalog doc id
unique-key = docid
index =
    name:docid          type:string  stored:true required:true
    name:UID            type:string  stored:true required:true
    name:SearchableText type:text    stored:false
    name:Title          type:text    stored:true
    name:Description    type:text    stored:false
# stored ... retrievable through index
# indexed ... true/false ... if field is searchable
#filter =
#    text solr.LowerCaseFilterFactory
#extra-field-types =

##############################################################################
# Rabbit MQ
##############################################################################
[rabbitmq]
recipe = rod.recipe.rabbitmq
url = http://www.rabbitmq.com/releases/rabbitmq-server/v2.7.0/rabbitmq-server-2.7.0.tar.gz

[rabbitmq-conf]
recipe = collective.recipe.template
input = ${buildout:directory}/buildout.d/rabbitmq-env.conf.in
output = ${buildout:directory}/etc/rabbitmq-env.conf

[rabbitmq-plugins]
recipe = collective.recipe.template
input = ${buildout:directory}/buildout.d/rabbitmq_enabled_plugins.in
output = ${buildout:directory}/etc/rabbitmq_enabled_plugins


##############################################################################
# MOAI
##############################################################################
[moai-config]
recipe = collective.recipe.template
input = ${buildout:directory}/buildout.d/moai.ini.in
output = ${buildout:directory}/etc/moai.ini

[moai]
recipe = zc.recipe.egg
eggs =
    MOAI
    PasteScript
    org.bccvl.moai
    oai_xhtml_wrapper

##############################################################################
# Build bibutils and install in buildout bin-directory
##############################################################################
[bibutils]
recipe = hexagonit.recipe.cmmi
url = http://downloads.sourceforge.net/project/bibutils/bibutils_4.14_src.tgz
configure-command =
make-options =
    INSTALLDIR=${buildout:bin-directory}
    LIBINSTALLDIR=${buildout:bin-directory}

##############################################################################
# Develop and test recipes
##############################################################################
[zopeip]
recipe = zc.recipe.egg
eggs =
    ipython
    ${instance-debug:eggs}
extra-paths = ${instance-settings:extra-paths}
scripts = ipython

# install paster scripts to ease development of new packages
# TODO: maybe extend this with various other paster templates
[zopeskel]
recipe = zc.recipe.egg
egg =
    ZopeSkel
    ${instance-settings:eggs}

[instance-ipython]
# an IPython Shell for interactive use with zope running.
# You also need to put
# https://svn.plone.org/svn/collective/dotipython/branches/plone4/
# ipy_profile_zope.py
# in your $HOME/.ipython directory for the following to work.
# You may have to remove an existing ipy_profile_zope.py: if you
# get errors when running ./bin/ipzope, check the stack trace for that
# filename to make sure the correct version is used.
recipe = zc.recipe.egg
eggs =
    ipython
    ${instance-debug:eggs}
initialization =
    import sys, os
    os.environ["INSTANCE_HOME"] = "${instance-debug:location}"
    sys.argv[1:1] = ["--profile=zope", ]
scripts = ipython=instance-ipython

# omelette source merger
[omelette]
recipe= collective.recipe.omelette
eggs = ${instance-settings:eggs}
ignore-develop = True

# Roadrunner - speeds up integration test runs
[roadrunner]
recipe = roadrunner:plone
zope2-instance = instance-debug
packages-under-test =
#    mynamespace

# zope test runner
[test]
recipe = zc.recipe.testrunner
eggs = ${instance-settings:eggs}
defaults = ['--auto-color', '--auto-progress']
#defaults = ['-s', 'my.pakcage', '--auto-color', '--auto-progress']

[test-coverage]
recipe = zc.recipe.testrunner
eggs = ${test:eggs}
defaults = ['--coverage', '../../coverage', '-v', '--auto-progress']

[test-coverage-report]
recipe = zc.recipe.egg
eggs = z3c.coverage
scripts = coverage=test-coverage-report
arguments = ('coverage', 'report')

##############################################################################
# Jenkins test stuff
##############################################################################
[jenkins]
jenkins-test-eggs = ${instance-settings:eggs}
jenkins-test-directories = ${instance-settings:eggs}

[jenkins-test]
# Creates a "jenkins-test" script in the bin directory of the buildout that
# runs the tests and outputs the results in an XML format that Jenkins can read
# and process.
#
# The output files can be included in Jenkins by enabling the
# "Publish JUnit test result report" setting in the "Post-build Actions"
# section of the Job configuration. The "Test report XMLs" field needs to point
# to "parts/jenkins-test/testreports/*.xml".
recipe = collective.xmltestreport
eggs = ${jenkins:jenkins-test-eggs}
script = jenkins-test
environment = jenkins-test-env
defaults = ['--auto-color', '--auto-progress', '--xml']

[jenkins-test-env]
zope_i18n_compile_mo_files = true

[jenkins-test-coverage]
# Creates a "jenkins-test-coverage" script in the bin directory of the buildout
# that runs a code coverage analysis and creates a report in an XML format that
# Jenkins can read and process. There is no need to run "bin/jenkins-test"
# before
recipe = collective.recipe.template
input = inline:
    #!/bin/sh
    # Remove old results
    echo "Erase old coverage results."
    ${:coverage} erase
    # Collect test coverage results for all packages
    echo "Run test coverage analysis for all packages."
    DIRECTORIES="${jenkins:jenkins-test-directories}"
    for pkgdir in $DIRECTORIES
    do
        # Runs a code coverage analysis on top of the "jenkins-test" script for
        # all packages. The data will be collected in a ".coverage" output file
        # in the buildout directory.
        echo "Analyse $pkgdir"
        ${:coverage} run -p --source=$pkgdir ${:jenkins-test} --all
    done
    echo "Create test coverage report."
    # Combine all package analysis
    ${:coverage} combine
    # Generates a "coverage.xml" file that Jenkins can read and process from the
    # ".coverage" file that the coverage report created.
    ${:coverage} xml -i -o ${buildout:parts-directory}/jenkins-test/coverage.xml
    echo "Test coverage report finished."
output = ${buildout:bin-directory}/jenkins-test-coverage
mode = 755
# FIXME: depend on coverage and jenkins-test recipe
coverage = ${coverage:bin-directory}/coverage
jenkins-test = ${jenkins-test:bin-directory}/jenkins-test

[coverage]
recipe = z3c.recipe.egg
#recipe = z3c.recipe.scripts
eggs = coverage
